<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cnlp.similarity_methods.local_similarity API documentation</title>
<meta name="description" content="Collection of Local Similarity Methods for Link Prediction â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cnlp.similarity_methods.local_similarity</code></h1>
</header>
<section id="section-intro">
<p>Collection of Local Similarity Methods for Link Prediction.</p>
<p>Local indices are generally calculated using information about
common neighbors and node degree.
These indices <strong>consider immediate neighbors of a node</strong>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Collection of Local Similarity Methods for Link Prediction.

Local indices are generally calculated using information about
common neighbors and node degree.
These indices **consider immediate neighbors of a node**.
&#34;&#34;&#34;
import networkx as nx
import numpy as np
from cnlp.utils import nodes_to_indexes
from scipy.sparse import lil_matrix, csr_matrix


def adamic_adar(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Adamic and Adar Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)}
        \\frac{1}{\\log k_z}

    where \\(k_z\\) is the degree of node \\(z\\)
    and \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    It is clear from the equation that more weights are assigned to
    the common neighbors having smaller degrees.
    This is also intuitive in the real-world scenario, for example,
    a person with more number of friends spend less time/resource
    with an individual friend as compared to the less number of friends.
    &#34;&#34;&#34;

    def __adamic_adar(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Adamic and Adar Index for 2 given nodes.&#34;&#34;&#34;
        return sum([1 / np.log(G.degree[z]) for z in set(G[x]) &amp; set(G[y])])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __adamic_adar(G, x, y)

    return S.tocsr()


def __common_neighbors(G: nx.Graph, x, y) -&gt; int:
    &#34;&#34;&#34;Compute the Common Neighbors Index for 2 given nodes.&#34;&#34;&#34;
    return len(set(G[x]).intersection(set(G[y])))


def common_neighbors(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Common Neighbors Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = |\\Gamma(x) \\cap \\Gamma(y)|

    where \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The likelihood of the existence of a link between \\(x\\)
    and \\(y\\) increases with the number of common neighbors between them.
    &#34;&#34;&#34;
    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __common_neighbors(G, x, y)
        # S[_y, _x] = S[_x, _y]

    return S.tocsr()


def cosine_similarity(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Cosine Similarity Index
    (a.k.a. Salton Index) for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{|\\Gamma(x) \\cap \\Gamma(y)|}{\\sqrt{k_x k_y}}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This similarity index between two nodes is measured by
    calculating the Cosine of the angle between them.
    The metric is all about the orientation and not magnitude.
    &#34;&#34;&#34;

    def __cosine_similarity(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Cosine Similarity Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / np.sqrt(G.degree[x] * G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __cosine_similarity(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def hub_depressed(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Depressed Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{\\max(k_x, k_y)}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).


    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This index is the same as the previous one but with the
    opposite goal as it avoids the formation of
    links between hubs and low degree nodes in the networks.
    The Hub depressed index promotes the links evolution
    between the hubs as well as the low degree nodes.
    &#34;&#34;&#34;

    def __hub_depressed(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Hub Depressed Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / max(G.degree[x], G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __hub_depressed(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def hub_promoted(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Promoted Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{\\min(k_x, k_y)}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This similarity index promotes the formation of links between
    the sparsely connected nodes and hubs.
    It also tries to prevent links formation between the hub nodes.
    &#34;&#34;&#34;

    def __hub_promoted(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Hub Promoted Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / min(G.degree[x], G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __hub_promoted(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def jaccard(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Jaccard Coefficient for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{| \\Gamma(x) \\cap \\Gamma(y)|}{| \\Gamma(x) \\cup \\Gamma(y)|}

    where \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The Jaccard coefficient is defined as the probability of selection
    of common neighbors of pairwise vertices from all the neighbors of
    either vertex. The pairwise Jaccard score increases with the number of
    common neighbors between the two vertices considered. Some researcher
    (**Liben-Nowell et al.**) demonstrated that this similarity metric
    performs worse as compared to Common Neighbors.
    &#34;&#34;&#34;

    def __jaccard(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Jaccard Coefficient for 2 given nodes.&#34;&#34;&#34;
        total_neighbor_number = len(set(G[x]).union(set(G[y])))
        if total_neighbor_number == 0:
            return 0
        
        return __common_neighbors(G, x, y) / total_neighbor_number

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __jaccard(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def node_clustering(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Depressed Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)} C(z)

    where

    .. math::
        C(z) = \\frac{t(z)}{k_z(k_z - 1)}

    is the clustering coefficient of node \\(z\\), \\(t(z)\\)
    is the total triangles passing through the node \\(z\\),
    \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This index is also based on the clustering coefficient property
    of the network in which the clustering coefficients of all
    the common neighbors of a seed node pair are computed
    and summed to find the final similarity score of the pair.
    &#34;&#34;&#34;

    def __t(G: nx.Graph, z) -&gt; int:
        &#34;&#34;&#34;Number of triangles passing through the node z&#34;&#34;&#34;
        return nx.triangles(G, z)

    def __C(G: nx.Graph, z) -&gt; float:
        &#34;&#34;&#34;Clustering Coefficient&#34;&#34;&#34;
        z_degree = G.degree[z]

        # avoiding 0 divition error
        if z_degree == 1:
            return 0

        return __t(G, z) / (z_degree * (z_degree - 1))

    def __node_clustering(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Node Clustering Coefficient for 2 given nodes.&#34;&#34;&#34;
        return sum([__C(G, z) for z in (set(G[x]) &amp; set(G[y]))])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __node_clustering(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def preferential_attachment(G: nx.Graph, sum: bool = False) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Preferential Attachment Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = k_x k_y

    where \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)
    sum: bool :
        Replace multiplication with summation when computing the index.
         (Default value = False)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The idea of preferential attachment is applied to generate a growing
    scale-free network. The term growing represents the incremental nature
    of nodes over time in the network. The likelihood incrementing new
    connection associated with a node \\(x\\) is proportional to
    \\(k_x\\), the degree of the node.

    This index shows the worst performance on most networks.
    The **simplicity** (as it requires the least information
    for the score calculation) and the computational time of this metric
    are the main advantages. PA shows better results if larger
    degree nodes are densely connected,
    and lower degree nodes are rarely connected.

    In the above equation, summation can also be used instead of
    multiplication as an aggregate function (`sum = True`).
    &#34;&#34;&#34;

    def __preferential_attachment(G: nx.Graph,
                                  x,
                                  y,
                                  sum: bool = False) -&gt; float:
        &#34;&#34;&#34;Compute the Preferential Attachment Index for 2 given nodes.&#34;&#34;&#34;
        return G.degree[x] * G.degree[y] if not sum else G.degree[
            x] + G.degree[y]

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __preferential_attachment(G, x, y, sum=sum)
        # S[y, x] = S[x, y]

    return S.tocsr()


def resource_allocation(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Resource Allocation Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)} \\frac{1}{k_z}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\) and
    \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    Consider two non-adjacent vertices \\(x\\) and \\(y\\).
    Suppose node \\(x\\) sends some resources to \\(y\\)
    through the common nodes of both \\(x\\) and \\(y\\)
    then the similarity between the two vertices is computed in terms
    of resources sent from \\(x\\) to \\(y\\).

    The difference between Resource Allocation (**RA**) and
    Adamic and Adar (**AA**) is that the RA index
    heavily penalizes to higher degree nodes compared to the AA index.
    Prediction results of these indices become almost the same
    for smaller average degree networks.

    This index shows good performance on heterogeneous
    networks with a high clustering coefficient, especially
    on transportation networks.
    &#34;&#34;&#34;

    def __resource_allocation(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Resource Allocation Index for 2 given nodes.&#34;&#34;&#34;
        return sum([1 / G.degree[z] for z in set(G[x]) &amp; set(G[y])])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __resource_allocation(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()


def sorensen(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Sorensen Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{k_x + k_y}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    It is very similar to the Jaccard index. **McCune et al.** show
    that it is more robust than Jaccard against the outliers.
    &#34;&#34;&#34;

    def __sorensen(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Sorensen Index for 2 given nodes.&#34;&#34;&#34;
        return (2 * __common_neighbors(G, x, y)) / (G.degree[x] + G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __sorensen(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="cnlp.similarity_methods.local_similarity.adamic_adar"><code class="name flex">
<span>def <span class="ident">adamic_adar</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Adamic and Adar Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)}
\frac{1}{\log k_z} </span><script type="math/tex; mode=display"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)}
\frac{1}{\log k_z} </script></span>
where <span><span class="MathJax_Preview">k_z</span><script type="math/tex">k_z</script></span> is the degree of node <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>
and <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>It is clear from the equation that more weights are assigned to
the common neighbors having smaller degrees.
This is also intuitive in the real-world scenario, for example,
a person with more number of friends spend less time/resource
with an individual friend as compared to the less number of friends.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adamic_adar(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Adamic and Adar Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)}
        \\frac{1}{\\log k_z}

    where \\(k_z\\) is the degree of node \\(z\\)
    and \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    It is clear from the equation that more weights are assigned to
    the common neighbors having smaller degrees.
    This is also intuitive in the real-world scenario, for example,
    a person with more number of friends spend less time/resource
    with an individual friend as compared to the less number of friends.
    &#34;&#34;&#34;

    def __adamic_adar(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Adamic and Adar Index for 2 given nodes.&#34;&#34;&#34;
        return sum([1 / np.log(G.degree[z]) for z in set(G[x]) &amp; set(G[y])])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __adamic_adar(G, x, y)

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.common_neighbors"><code class="name flex">
<span>def <span class="ident">common_neighbors</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Common Neighbors Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = |\Gamma(x) \cap \Gamma(y)| </span><script type="math/tex; mode=display"> S(x, y) = |\Gamma(x) \cap \Gamma(y)| </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The likelihood of the existence of a link between <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span> increases with the number of common neighbors between them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def common_neighbors(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Common Neighbors Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = |\\Gamma(x) \\cap \\Gamma(y)|

    where \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The likelihood of the existence of a link between \\(x\\)
    and \\(y\\) increases with the number of common neighbors between them.
    &#34;&#34;&#34;
    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __common_neighbors(G, x, y)
        # S[_y, _x] = S[_x, _y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.cosine_similarity"><code class="name flex">
<span>def <span class="ident">cosine_similarity</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Cosine Similarity Index
(a.k.a. Salton Index) for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \frac{|\Gamma(x) \cap \Gamma(y)|}{\sqrt{k_x k_y}} </span><script type="math/tex; mode=display"> S(x, y) = \frac{|\Gamma(x) \cap \Gamma(y)|}{\sqrt{k_x k_y}} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This similarity index between two nodes is measured by
calculating the Cosine of the angle between them.
The metric is all about the orientation and not magnitude.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cosine_similarity(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Cosine Similarity Index
    (a.k.a. Salton Index) for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{|\\Gamma(x) \\cap \\Gamma(y)|}{\\sqrt{k_x k_y}}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This similarity index between two nodes is measured by
    calculating the Cosine of the angle between them.
    The metric is all about the orientation and not magnitude.
    &#34;&#34;&#34;

    def __cosine_similarity(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Cosine Similarity Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / np.sqrt(G.degree[x] * G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __cosine_similarity(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.hub_depressed"><code class="name flex">
<span>def <span class="ident">hub_depressed</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Hub Depressed Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{\max(k_x, k_y)} </span><script type="math/tex; mode=display"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{\max(k_x, k_y)} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This index is the same as the previous one but with the
opposite goal as it avoids the formation of
links between hubs and low degree nodes in the networks.
The Hub depressed index promotes the links evolution
between the hubs as well as the low degree nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hub_depressed(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Depressed Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{\\max(k_x, k_y)}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).


    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This index is the same as the previous one but with the
    opposite goal as it avoids the formation of
    links between hubs and low degree nodes in the networks.
    The Hub depressed index promotes the links evolution
    between the hubs as well as the low degree nodes.
    &#34;&#34;&#34;

    def __hub_depressed(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Hub Depressed Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / max(G.degree[x], G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __hub_depressed(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.hub_promoted"><code class="name flex">
<span>def <span class="ident">hub_promoted</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Hub Promoted Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{\min(k_x, k_y)} </span><script type="math/tex; mode=display"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{\min(k_x, k_y)} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This similarity index promotes the formation of links between
the sparsely connected nodes and hubs.
It also tries to prevent links formation between the hub nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hub_promoted(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Promoted Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{\\min(k_x, k_y)}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This similarity index promotes the formation of links between
    the sparsely connected nodes and hubs.
    It also tries to prevent links formation between the hub nodes.
    &#34;&#34;&#34;

    def __hub_promoted(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Hub Promoted Index for 2 given nodes.&#34;&#34;&#34;
        return __common_neighbors(G, x, y) / min(G.degree[x], G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __hub_promoted(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.jaccard"><code class="name flex">
<span>def <span class="ident">jaccard</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Jaccard Coefficient for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \frac{| \Gamma(x) \cap \Gamma(y)|}{| \Gamma(x) \cup \Gamma(y)|} </span><script type="math/tex; mode=display"> S(x, y) = \frac{| \Gamma(x) \cap \Gamma(y)|}{| \Gamma(x) \cup \Gamma(y)|} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The Jaccard coefficient is defined as the probability of selection
of common neighbors of pairwise vertices from all the neighbors of
either vertex. The pairwise Jaccard score increases with the number of
common neighbors between the two vertices considered. Some researcher
(<strong>Liben-Nowell et al.</strong>) demonstrated that this similarity metric
performs worse as compared to Common Neighbors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def jaccard(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Jaccard Coefficient for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{| \\Gamma(x) \\cap \\Gamma(y)|}{| \\Gamma(x) \\cup \\Gamma(y)|}

    where \\(\\Gamma(x)\\) are the neighbors of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The Jaccard coefficient is defined as the probability of selection
    of common neighbors of pairwise vertices from all the neighbors of
    either vertex. The pairwise Jaccard score increases with the number of
    common neighbors between the two vertices considered. Some researcher
    (**Liben-Nowell et al.**) demonstrated that this similarity metric
    performs worse as compared to Common Neighbors.
    &#34;&#34;&#34;

    def __jaccard(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Jaccard Coefficient for 2 given nodes.&#34;&#34;&#34;
        total_neighbor_number = len(set(G[x]).union(set(G[y])))
        if total_neighbor_number == 0:
            return 0
        
        return __common_neighbors(G, x, y) / total_neighbor_number

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __jaccard(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.node_clustering"><code class="name flex">
<span>def <span class="ident">node_clustering</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Hub Depressed Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)} C(z) </span><script type="math/tex; mode=display"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)} C(z) </script></span>
where</p>
<p><span><span class="MathJax_Preview"> C(z) = \frac{t(z)}{k_z(k_z - 1)} </span><script type="math/tex; mode=display"> C(z) = \frac{t(z)}{k_z(k_z - 1)} </script></span>
is the clustering coefficient of node <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>, <span><span class="MathJax_Preview">t(z)</span><script type="math/tex">t(z)</script></span>
is the total triangles passing through the node <span><span class="MathJax_Preview">z</span><script type="math/tex">z</script></span>,
<span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>This index is also based on the clustering coefficient property
of the network in which the clustering coefficients of all
the common neighbors of a seed node pair are computed
and summed to find the final similarity score of the pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def node_clustering(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Hub Depressed Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)} C(z)

    where

    .. math::
        C(z) = \\frac{t(z)}{k_z(k_z - 1)}

    is the clustering coefficient of node \\(z\\), \\(t(z)\\)
    is the total triangles passing through the node \\(z\\),
    \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    This index is also based on the clustering coefficient property
    of the network in which the clustering coefficients of all
    the common neighbors of a seed node pair are computed
    and summed to find the final similarity score of the pair.
    &#34;&#34;&#34;

    def __t(G: nx.Graph, z) -&gt; int:
        &#34;&#34;&#34;Number of triangles passing through the node z&#34;&#34;&#34;
        return nx.triangles(G, z)

    def __C(G: nx.Graph, z) -&gt; float:
        &#34;&#34;&#34;Clustering Coefficient&#34;&#34;&#34;
        z_degree = G.degree[z]

        # avoiding 0 divition error
        if z_degree == 1:
            return 0

        return __t(G, z) / (z_degree * (z_degree - 1))

    def __node_clustering(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Node Clustering Coefficient for 2 given nodes.&#34;&#34;&#34;
        return sum([__C(G, z) for z in (set(G[x]) &amp; set(G[y]))])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __node_clustering(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.preferential_attachment"><code class="name flex">
<span>def <span class="ident">preferential_attachment</span></span>(<span>G:Â networkx.classes.graph.Graph, sum:Â boolÂ =Â False) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Preferential Attachment Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = k_x k_y </span><script type="math/tex; mode=display"> S(x, y) = k_x k_y </script></span>
where <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
<dt><strong><code>sum</code></strong> :&ensp;<code>bool :</code></dt>
<dd>Replace multiplication with summation when computing the index.
(Default value = False)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>The idea of preferential attachment is applied to generate a growing
scale-free network. The term growing represents the incremental nature
of nodes over time in the network. The likelihood incrementing new
connection associated with a node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> is proportional to
<span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span>, the degree of the node.</p>
<p>This index shows the worst performance on most networks.
The <strong>simplicity</strong> (as it requires the least information
for the score calculation) and the computational time of this metric
are the main advantages. PA shows better results if larger
degree nodes are densely connected,
and lower degree nodes are rarely connected.</p>
<p>In the above equation, summation can also be used instead of
multiplication as an aggregate function (<code>sum = True</code>).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preferential_attachment(G: nx.Graph, sum: bool = False) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Preferential Attachment Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = k_x k_y

    where \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)
    sum: bool :
        Replace multiplication with summation when computing the index.
         (Default value = False)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    The idea of preferential attachment is applied to generate a growing
    scale-free network. The term growing represents the incremental nature
    of nodes over time in the network. The likelihood incrementing new
    connection associated with a node \\(x\\) is proportional to
    \\(k_x\\), the degree of the node.

    This index shows the worst performance on most networks.
    The **simplicity** (as it requires the least information
    for the score calculation) and the computational time of this metric
    are the main advantages. PA shows better results if larger
    degree nodes are densely connected,
    and lower degree nodes are rarely connected.

    In the above equation, summation can also be used instead of
    multiplication as an aggregate function (`sum = True`).
    &#34;&#34;&#34;

    def __preferential_attachment(G: nx.Graph,
                                  x,
                                  y,
                                  sum: bool = False) -&gt; float:
        &#34;&#34;&#34;Compute the Preferential Attachment Index for 2 given nodes.&#34;&#34;&#34;
        return G.degree[x] * G.degree[y] if not sum else G.degree[
            x] + G.degree[y]

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __preferential_attachment(G, x, y, sum=sum)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.resource_allocation"><code class="name flex">
<span>def <span class="ident">resource_allocation</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Resource Allocation Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)} \frac{1}{k_z} </span><script type="math/tex; mode=display"> S(x, y) = \sum_{z \in \Gamma(x) \cap \Gamma(y)} \frac{1}{k_z} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and
<span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Consider two non-adjacent vertices <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>.
Suppose node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> sends some resources to <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>
through the common nodes of both <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> and <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>
then the similarity between the two vertices is computed in terms
of resources sent from <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span> to <span><span class="MathJax_Preview">y</span><script type="math/tex">y</script></span>.</p>
<p>The difference between Resource Allocation (<strong>RA</strong>) and
Adamic and Adar (<strong>AA</strong>) is that the RA index
heavily penalizes to higher degree nodes compared to the AA index.
Prediction results of these indices become almost the same
for smaller average degree networks.</p>
<p>This index shows good performance on heterogeneous
networks with a high clustering coefficient, especially
on transportation networks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resource_allocation(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Resource Allocation Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\sum_{z \\in \\Gamma(x) \\cap \\Gamma(y)} \\frac{1}{k_z}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\) and
    \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    Consider two non-adjacent vertices \\(x\\) and \\(y\\).
    Suppose node \\(x\\) sends some resources to \\(y\\)
    through the common nodes of both \\(x\\) and \\(y\\)
    then the similarity between the two vertices is computed in terms
    of resources sent from \\(x\\) to \\(y\\).

    The difference between Resource Allocation (**RA**) and
    Adamic and Adar (**AA**) is that the RA index
    heavily penalizes to higher degree nodes compared to the AA index.
    Prediction results of these indices become almost the same
    for smaller average degree networks.

    This index shows good performance on heterogeneous
    networks with a high clustering coefficient, especially
    on transportation networks.
    &#34;&#34;&#34;

    def __resource_allocation(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Resource Allocation Index for 2 given nodes.&#34;&#34;&#34;
        return sum([1 / G.degree[z] for z in set(G[x]) &amp; set(G[y])])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __resource_allocation(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
<dt id="cnlp.similarity_methods.local_similarity.sorensen"><code class="name flex">
<span>def <span class="ident">sorensen</span></span>(<span>G:Â networkx.classes.graph.Graph) â€‘>Â scipy.sparse._csr.csr_matrix</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Sorensen Index for all nodes in the Graph.
Each similarity value is defined as:</p>
<p><span><span class="MathJax_Preview"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{k_x + k_y} </span><script type="math/tex; mode=display"> S(x, y) = \frac{2 |\Gamma(x) \cap \Gamma(y)|}{k_x + k_y} </script></span>
where <span><span class="MathJax_Preview">\Gamma(x)</span><script type="math/tex">\Gamma(x)</script></span> are the neighbors of node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>
and <span><span class="MathJax_Preview">k_x</span><script type="math/tex">k_x</script></span> is the degree of the node <span><span class="MathJax_Preview">x</span><script type="math/tex">x</script></span>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>G</code></strong> :&ensp;<code>nx.Graph :</code></dt>
<dd>input Graph (a networkx Graph)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>S</code></strong> :&ensp;<code>csr_matrix : the Similarity Matrix (in sparse format)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>It is very similar to the Jaccard index. <strong>McCune et al.</strong> show
that it is more robust than Jaccard against the outliers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorensen(G: nx.Graph) -&gt; csr_matrix:
    &#34;&#34;&#34;Compute the Sorensen Index for all nodes in the Graph.
    Each similarity value is defined as:

    .. math::
        S(x, y) = \\frac{2 |\\Gamma(x) \\cap \\Gamma(y)|}{k_x + k_y}

    where \\(\\Gamma(x)\\) are the neighbors of node \\(x\\)
    and \\(k_x\\) is the degree of the node \\(x\\).

    Parameters
    ----------
    G: nx.Graph :
        input Graph (a networkx Graph)

    Returns
    -------
    S: csr_matrix : the Similarity Matrix (in sparse format)

    Notes
    -----
    It is very similar to the Jaccard index. **McCune et al.** show
    that it is more robust than Jaccard against the outliers.
    &#34;&#34;&#34;

    def __sorensen(G: nx.Graph, x, y) -&gt; float:
        &#34;&#34;&#34;Compute the Sorensen Index for 2 given nodes.&#34;&#34;&#34;
        return (2 * __common_neighbors(G, x, y)) / (G.degree[x] + G.degree[y])

    size = G.number_of_nodes()
    S = lil_matrix((size, size))
    node_index_map = nodes_to_indexes(G)

    for x, y in nx.complement(G).edges():
        _x = node_index_map[x]
        _y = node_index_map[y]

        S[_x, _y] = __sorensen(G, x, y)
        # S[y, x] = S[x, y]

    return S.tocsr()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cnlp.similarity_methods" href="index.html">cnlp.similarity_methods</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="cnlp.similarity_methods.local_similarity.adamic_adar" href="#cnlp.similarity_methods.local_similarity.adamic_adar">adamic_adar</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.common_neighbors" href="#cnlp.similarity_methods.local_similarity.common_neighbors">common_neighbors</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.cosine_similarity" href="#cnlp.similarity_methods.local_similarity.cosine_similarity">cosine_similarity</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.hub_depressed" href="#cnlp.similarity_methods.local_similarity.hub_depressed">hub_depressed</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.hub_promoted" href="#cnlp.similarity_methods.local_similarity.hub_promoted">hub_promoted</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.jaccard" href="#cnlp.similarity_methods.local_similarity.jaccard">jaccard</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.node_clustering" href="#cnlp.similarity_methods.local_similarity.node_clustering">node_clustering</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.preferential_attachment" href="#cnlp.similarity_methods.local_similarity.preferential_attachment">preferential_attachment</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.resource_allocation" href="#cnlp.similarity_methods.local_similarity.resource_allocation">resource_allocation</a></code></li>
<li><code><a title="cnlp.similarity_methods.local_similarity.sorensen" href="#cnlp.similarity_methods.local_similarity.sorensen">sorensen</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>